import { Injectable, OnModuleInit } from '@nestjs/common';
import { WoService } from 'src/wo/wo.service';
import writeXlsxFile from 'write-excel-file/node';
import * as fs from 'fs';
import * as ejs from 'ejs';
import * as htmlPDF from 'html-pdf-node';
// const writeXlsxFile = require('write-excel-file/node')
import * as _ from 'lodash';
import { CronJob } from 'cron';
import { SchedulerRegistry, Cron } from '@nestjs/schedule';
import { PoService } from 'src/po/po.service';
import { UserService } from 'src/user/user.service';
import config from 'src/config';
import { EmailService } from 'src/email/email.service';
import { NotificationEntity } from 'src/notification/entities/notification.entity';
import { NotificationService } from 'src/notification/notification.service';
import {
  getAssignedTechsNameArray,
  getWorkOrderStatus,
  getPurchaseOrderStatus,
  formatDate,
  timeToDecimal,
  timezoneMap,
  getPrimaryAndSecondaryTechs,
  getFormattedTechName,
} from 'src/core/common/common';
import * as moment from 'moment';
import * as momenttz from 'moment-timezone';
import { BranchService } from 'src/branch/branch.service';
import { WoEntity } from 'src/wo/entities/wo.entity';
import { UserEntity } from 'src/user/entities/user.entity';
import { OffsetWithoutLimitNotSupportedError, Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { ReportService } from 'src/report/report.service';
import { TechnicianService } from 'src/technician/technician.service';
import { PusherService } from 'src/pusher/pusher.service';

const schema = [
  {
    column: 'WO#',
    type: String,
    width: 15,
    wrap: true,
    align: 'center',
    alignVertical: 'center',
    value: (order) => order.number,
  },
  {
    column: 'Type',
    type: String,
    width: 15,
    wrap: true,
    align: 'center',
    alignVertical: 'center',
    value: (order) => order.type,
  },
  {
    column: 'Customer',
    type: String,
    width: 20,
    wrap: true,
    align: 'center',
    alignVertical: 'center',
    value: (order) => order.customer,
  },
  {
    column: 'NTE',
    type: Number,
    width: 10,
    wrap: true,
    align: 'center',
    alignVertical: 'center',
    value: (order) => order.NTE,
  },
  {
    column: 'Description',
    type: String,
    width: 50,
    wrap: true,
    align: 'center',
    alignVertical: 'center',
    value: (order) => order.description,
  },
  {
    column: 'Technician',
    type: String,
    width: 30,
    wrap: true,
    align: 'center',
    alignVertical: 'center',
    value: (order) => order.technician,
  },
  {
    column: 'Status',
    type: String,
    width: 10,
    wrap: true,
    align: 'center',
    alignVertical: 'center',
    value: (order) => order.status,
  },
];

@Injectable()
export class ScheduledTaskService implements OnModuleInit {
  constructor(
    @InjectRepository(WoEntity) private woRepo: Repository<WoEntity>,
    @InjectRepository(UserEntity) private userRepo: Repository<UserEntity>,
    private readonly woService: WoService,
    private readonly poService: PoService,
    private readonly userService: UserService,
    private readonly emailService: EmailService,
    private readonly notificationService: NotificationService,
    private readonly branchService: BranchService,
    private readonly reportService: ReportService,
    private readonly technicianService: TechnicianService,
    private readonly pusherService: PusherService,
    private schedulerRegistry: SchedulerRegistry,
  ) { }

  onModuleInit() { }

  @Cron('* * * * *', {
    timeZone: 'Pacific/Honolulu',
  })
  async handleAutoGeneratedReport() {
    this.sendAutoGeneratedReport();
    this.sendDailyTimeLogReminder();
  }

  async sendAutoGeneratedReport() {
    // For now, we will use 'rscs' as the default company
    // In the future, this could be enhanced to handle multiple companies
    const company = 'rscs';

    // Get all reports for the default company
    let reportArray = await this.reportService.getAllReport(company);

    // Process reports for the default company
    for (let report of reportArray) {
      if (report.cycle === 0) {
        //weekly
        const weekday = momenttz()
          .tz(timezoneMap[report.branch.timezone])
          .weekday();

        const currentHour = Number(
          momenttz().tz(timezoneMap[report.branch.timezone]).format('HH'),
        );
        const currentMinute = Number(
          momenttz().tz(timezoneMap[report.branch.timezone]).format('mm'),
        );
        const scheduledHour = Number(report.time.split(':')[0]);
        const scheduledMinute = Number(report.time.split(':')[1]);

        if (
          weekday === report.day &&
          currentHour === scheduledHour &&
          currentMinute === scheduledMinute
        ) {
          this.sendAutoGeneratedReportEmail(
            report.technicians.split(','),
            report.recipients.split(','),
            report.cycle,
            report.type,
            report.branch,
            company,
          );
        }
      } else if (report.cycle === 1) {
        //monthly
        const lastDay = momenttz()
          .tz(timezoneMap[report.branch.timezone])
          .endOf('month')
          .date();
        let scheduledDay = Number(report.day);
        scheduledDay = scheduledDay > lastDay ? lastDay : scheduledDay;
        const currentDay = momenttz()
          .tz(timezoneMap[report.branch.timezone])
          .date();

        const currentHour = Number(
          momenttz().tz(timezoneMap[report.branch.timezone]).format('HH'),
        );
        const currentMinute = Number(
          momenttz().tz(timezoneMap[report.branch.timezone]).format('mm'),
        );
        const scheduledHour = Number(report.time.split(':')[0]);
        const scheduledMinute = Number(report.time.split(':')[1]);

        if (
          currentDay === scheduledDay &&
          currentHour === scheduledHour &&
          currentMinute === scheduledMinute
        ) {
          this.sendAutoGeneratedReportEmail(
            report.technicians.split(','),
            report.recipients.split(','),
            report.cycle,
            report.type,
            report.branch,
            company,
          );
        }
      } else if (report.cycle === 2) {
        //Daily
        const currentHour = Number(
          momenttz().tz(timezoneMap[report.branch.timezone]).format('HH'),
        );
        const currentMinute = Number(
          momenttz().tz(timezoneMap[report.branch.timezone]).format('mm'),
        );
        const scheduledHour = Number(report.time.split(':')[0]);
        const scheduledMinute = Number(report.time.split(':')[1]);

        if (
          currentHour === scheduledHour &&
          currentMinute === scheduledMinute
        ) {
          this.sendAutoGeneratedReportEmail(
            report.technicians.split(','),
            report.recipients.split(','),
            report.cycle,
            report.type,
            report.branch,
            company,
          );
        }
      }
    }
  }

  async sendAutoGeneratedReportEmail(
    techIds,
    repicientIds,
    cycle,
    type,
    branch,
    company,
  ) {
    switch (type) {
      case 0:
        this.sendOpenWOReport(techIds, repicientIds, cycle, branch, company);
        break;
      case 1:
        this.sendCompletedWOReport(
          techIds,
          repicientIds,
          cycle,
          branch,
          company,
        );
        break;
      case 2:
        this.sendReviewedWOReport(
          techIds,
          repicientIds,
          cycle,
          branch,
          company,
        );
        break;
      case 3:
        this.sendBilledWOReport(techIds, repicientIds, cycle, branch, company);
        break;
      case 10:
        this.sendOpenPOReport(techIds, repicientIds, cycle, branch, company);
        break;
      case 20:
        this.sendTimeCard(techIds, repicientIds, cycle, branch, company);
        break;
    }
  }

  async sendTimeCard(techIds, repicientIds, cycle, branch, company) {
    const schema = [
      {
        column: 'Technician',
        type: String,
        width: 25,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.technician,
      },
      {
        column: 'Customer',
        type: String,
        width: 35,
        wrap: true,
        align: 'center',
        alignVertical: 'left',
        value: (order) => order.customer,
      },
      {
        column: 'WO #',
        type: String,
        width: 15,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.woNumber,
      },
      {
        column: 'Date',
        type: String,
        width: 15,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.date,
      },
      {
        column: 'Regular Time',
        type: String,
        width: 15,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.regularTime,
      },
      {
        column: 'Over Time',
        type: String,
        width: 15,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.overTime,
      },
      {
        column: 'Travel Time',
        type: String,
        width: 15,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.travelTime,
      },
    ];

    let allUsers = await this.userService.getAll(company);

    let technicians = allUsers.filter((user) =>
      techIds.includes(String(user.id)),
    );

    // Sort technicians alphabetically by last name and first name
    technicians = technicians.sort((a, b) => {
      const formattedNameA = getFormattedTechName(a.name);
      const formattedNameB = getFormattedTechName(b.name);
      return formattedNameA.localeCompare(formattedNameB);
    });
    let recipients = allUsers.filter(
      (user) =>
        repicientIds.includes(String(user.id)) && user.isEnabled === true,
    );

    if (cycle === 0) {
      //Weekly
      let today = momenttz().tz(timezoneMap[branch.timezone]);
      let lastSaturday =
        today.day() >= 6 ? today.clone().day(6) : today.clone().day(-1);

      let startDate = lastSaturday
        .clone()
        .subtract(6, 'days')
        .format('MM/DD/YYYY');
      let endDate = lastSaturday.clone().format('MM/DD/YYYY');

      let attachments = [];
      for (let tech of technicians) {
        let timeArray = await this.technicianService.getWeeklyTimeCards(
          tech.id,
          startDate,
          endDate,
        );

        let timeCard = { name: tech.name, endingDate: endDate, timeArray };

        //calculate total regular time and over time for the week.

        let weekRegTime = 0;
        let weekOverTime = 0;
        let weekTravelTime = 0;

        for (let item of timeArray) {
          for (let time of item.timeArray) {
            if (time.regularTime) weekRegTime += time.regularTime;
            if (time.overTime) weekOverTime += time.overTime;
            if (time.travelTime) weekTravelTime += time.travelTime;
          }
        }

        timeCard['weekRegTime'] = weekRegTime;
        timeCard['weekOverTime'] = weekOverTime;
        timeCard['weekTravelTime'] = weekTravelTime;
        //calculate the total regular time and over time for every day.
        let dayTotalHours = [];
        for (let i = 0; i < 7; i++) {
          let date = moment(startDate, 'MM/DD/YYYY').add(i, 'days');
          let regularTime = 0,
            overTime = 0;
          for (let time of timeArray) {
            for (let item of time.timeArray) {
              if (moment(item.date, 'MM/DD/YYYY').isSame(date, 'day')) {
                if (item.regularTime) regularTime += item.regularTime;
                if (item.overTime) overTime += item.overTime;
              }
            }
          }
          dayTotalHours.push({
            offset: i,
            date: date.format('YYYY-MM-DD'),
            regularTime: regularTime,
            overTime: overTime,
          });
        }

        timeCard['dayTotalHours'] = dayTotalHours;

        console.log(
          'ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€:',
          JSON.stringify(timeCard),
        );

        //creating PDF file

        let path =
          'src/core/templates/weeklytimecard/weekly_timecard_report_template.html';
        if (
          process.env.NODE_ENV === 'production' ||
          process.env.NODE_ENV === 'staging'
        ) {
          path =
            'core/templates/weeklytimecard/weekly_timecard_report_template.html';
        }

        const template = await fs.promises.readFile(path, 'utf-8');

        const renderedHtml = ejs.render(template, timeCard);

        let options = {
          format: 'A4',
          width: '8.5in',
          height: '11in',
          title: 'Service Ticket',
          margin: { top: 40, left: 20, right: 20, bottom: 20 },
        };
        let file = { content: renderedHtml };

        const pdfBuffer = await htmlPDF.generatePdf(file, options);

        const fileName = `Weekly_TimeCard_${tech.name}_${moment().format(
          'YYYY_MM_DD',
        )}.pdf`;
        const filePath = `./public/${company}/weeklytimecardreport/${fileName}`;

        await fs.promises.writeFile(filePath, pdfBuffer);

        const attachment = fs.readFileSync(filePath).toString('base64');
        attachments.push({
          content: attachment,
          filename: fileName,
          type: 'application/pdf',
          disposition: 'attachment',
        });
      }

      let recipientEmailArray = recipients.map((user) => user.email);

      //send email
      const mailOptions = {
        from: config.mail.supportEmail,
        to: recipientEmailArray,
        // to: ['yigitmufata3@gmail.com'],
        subject: `Weekly Time Card Report`,
        text: `Weekly Time Card Report`,
        html: ' ',
        attachments: attachments,
      };
      this.emailService.sendEmail(mailOptions);
    } else if (cycle === 2) {
      //Daily
      let today = momenttz().tz(timezoneMap[branch.timezone]);

      let timeCardArray = [];
      for (let tech of technicians) {
        if (!tech.isEnabled) {
          continue;
        }
        let timeCard = await this.technicianService.getDailyTimeCards(
          tech.id,
          today,
        );
        if (timeCard.length > 0) {
          timeCardArray.push(timeCard);
        }
      }

      let data = { timeCard: timeCardArray, branch: branch.name };

      //creating PDF file

      let path =
        'src/core/templates/dailytimecard/daily_timecard_report_template.html';
      if (
        process.env.NODE_ENV === 'production' ||
        process.env.NODE_ENV === 'staging'
      ) {
        path =
          'core/templates/dailytimecard/daily_timecard_report_template.html';
      }

      const template = await fs.promises.readFile(path, 'utf-8');

      const renderedHtml = ejs.render(template, data);

      let options = {
        format: 'A4',
        width: '8.5in',
        height: '11in',
        title: 'Service Ticket',
        margin: { top: 40, left: 20, right: 20, bottom: 20 },
      };
      let file = { content: renderedHtml };

      const pdfBuffer = await htmlPDF.generatePdf(file, options);

      const fileName = `${branch.name.replace(
        /[\\/]/g,
        '_',
      )} Daily Report_${today.format('YYYY_MM_DD')}.pdf`;
      const filePath = `./public/${company}/dailytimecardreport/${fileName}`;

      await fs.promises.writeFile(filePath, pdfBuffer);

      const attachment = fs.readFileSync(filePath).toString('base64');

      let recipientEmailArray = recipients.map((user) => user.email);

      //send email
      const mailOptions = {
        from: config.mail.supportEmail,
        to: recipientEmailArray,
        subject: `${branch.name} Daily Report`,
        text: `${branch.name} Daily Report`,
        html: ' ',
        attachments: [
          {
            content: attachment,
            filename: fileName,
            type: 'application/pdf',
            disposition: 'attachment',
          },
        ],
      };
      this.emailService.sendEmail(mailOptions);
    } else if (cycle === 1) {
      //Monthly
      let startDate = moment()
        .tz(timezoneMap[branch.timezone])
        .startOf('month')
        .format('YYYY-MM-DD');
      let endDate = moment()
        .tz(timezoneMap[branch.timezone])
        .endOf('month')
        .format('YYYY-MM-DD');

      let timeCardArray = [];
      for (let tech of technicians) {
        let timeCards = await this.technicianService.getTimeCards(
          tech.id,
          startDate,
          endDate,
          branch.id,
        );
        const updatedtimeCards = timeCards.map((item) => ({
          ...item,
          technician: tech.name,
        }));
        timeCardArray.push(...updatedtimeCards);
      }

      let recipientEmailArray = recipients.map((user) => user.email);

      const fileName = `Monthly_Report_For_TimeCards_${moment().format(
        'YYYY_MM_DD',
      )}.xlsx`;
      const filePath = `./public/${company}/reports/${fileName}`;
      if (!fs.existsSync(`./public/${company}/reports/`)) {
        fs.mkdirSync(`./public/${company}/reports/`, { recursive: true });
      }
      await writeXlsxFile(timeCardArray, {
        schema,
        headerStyle: {
          backgroundColor: '#eeeeee',
          fontWeight: 'bold',
          align: 'center',
        },
        filePath: filePath,
      });

      let attachment = fs.readFileSync(filePath).toString('base64');

      try {
        const mailOptions = {
          from: config.mail.supportEmail,
          to: recipientEmailArray,
          subject: 'Monthly_Report_For_TimeCards',
          text: ' ',
          html: ' ',
          attachments: [
            {
              content: attachment,
              filename: fileName,
              type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
              disposition: 'attachment',
            },
          ],
        };

        let result = await this.emailService.sendEmail(mailOptions);
      } catch (e) {
        console.log(e);
      }
    }
  }

  async sendOpenPOReport(techIds, repicientIds, cycle, branch, company) {
    const schema = [
      {
        column: 'PO#',
        type: String,
        width: 10,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.number,
      },
      {
        column: 'Vendor',
        type: String,
        width: 25,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.vendor,
      },
      {
        column: 'Description',
        type: String,
        width: 45,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.description,
      },
      {
        column: 'Technician',
        type: String,
        width: 35,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.technician,
      },
      {
        column: 'Parent WO#',
        type: String,
        width: 15,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.parentWO,
      },
      {
        column: 'Customer',
        type: String,
        width: 30,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.customer,
      },
      {
        column: 'Issued By',
        type: String,
        width: 25,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.issuedBy,
      },
      {
        column: 'Stataus',
        type: String,
        width: 15,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.status,
      },
    ];

    let allUsers = await this.userService.getAll(company);

    let technicians = allUsers.filter((user) =>
      techIds.includes(String(user.id)),
    );
    let recipients = allUsers.filter(
      (user) =>
        repicientIds.includes(String(user.id)) && user.isEnabled === true,
    );

    let openPOArray = [];
    for (let tech of technicians) {
      let assignedPOs = await this.poService.findAssignedOpenPurchaseOrders(
        tech.id,
        branch.id,
      );
      openPOArray.push(...assignedPOs);
    }

    let data = [];
    for (let order of openPOArray) {
      const row = {
        number: order.number,
        vendor: order.vendor,
        description: order.description,
        technician: order.issuedUser?.name,
        parentWO: order.wo.number,
        customer: order.wo.customer.companyName,
        issuedBy: order.issuedUser?.name,
        status: getPurchaseOrderStatus(order.status),
      };
      data.push(row);
    }
    let recipientEmailArray = recipients.map((user) => user.email);

    const fileName = `${cycle === 0 ? 'Weekly' : 'Monthly'
      }_Report_For_Open_POs_${moment().format('YYYY_MM_DD')}.xlsx`;
    const filePath = `./public/${company}/reports/${fileName}`;
    if (!fs.existsSync(`./public/${company}/reports/`)) {
      fs.mkdirSync(`./public/${company}/reports/`, { recursive: true });
    }
    await writeXlsxFile(data, {
      schema,
      headerStyle: {
        backgroundColor: '#eeeeee',
        fontWeight: 'bold',
        align: 'center',
      },
      filePath: filePath,
    });

    let attachment = fs.readFileSync(filePath).toString('base64');

    try {
      const mailOptions = {
        from: config.mail.supportEmail,
        to: recipientEmailArray,
        subject: `${cycle === 0 ? 'Weekly' : 'Monthly'}_Report_For_Open_POs`,
        text: ' ',
        html: ' ',
        attachments: [
          {
            content: attachment,
            filename: fileName,
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            disposition: 'attachment',
          },
        ],
      };

      this.emailService.sendEmail(mailOptions);
    } catch (e) {
      console.log(e);
    }
  }

  async sendOpenWOReport(techIds, repicientIds, cycle, branch, company) {
    let allUsers = await this.userService.getAll(company);

    let technicians = allUsers.filter((user) =>
      techIds.includes(String(user.id)),
    );
    let recipients = allUsers.filter(
      (user) =>
        repicientIds.includes(String(user.id)) && user.isEnabled === true,
    );

    let openWOArray = [];
    for (let tech of technicians) {
      let assignedWOs = await this.woService.findAssignedOpenOrders(
        tech.id,
        branch.id,
      );
      openWOArray.push(...assignedWOs);
    }

    let data = [];
    for (let order of openWOArray) {
      const row = {
        number: order.number,
        type: order.type == 0 ? 'Service Call' : 'Quoted',
        customer: order.customer?.companyName,
        NTE: order.NTE,
        description: order.description,
        technician: getAssignedTechsNameArray(order.assignedTechs),
        status: getWorkOrderStatus(order.status),
      };
      data.push(row);
    }

    let recipientEmailArray = recipients.map((user) => user.email);

    const fileName = `${cycle === 0 ? 'Weekly' : 'Monthly'
      }_Report_For_Open_WOs_${moment().format('YYYY_MM_DD')}.xlsx`;
    const filePath = `./public/${company}/reports/${fileName}`;
    if (!fs.existsSync(`./public/${company}/reports/`)) {
      fs.mkdirSync(`./public/${company}/reports/`, { recursive: true });
    }
    await writeXlsxFile(data, {
      schema,
      headerStyle: {
        backgroundColor: '#eeeeee',
        fontWeight: 'bold',
        align: 'center',
      },
      filePath: filePath,
    });

    let attachment = fs.readFileSync(filePath).toString('base64');

    try {
      const mailOptions = {
        from: config.mail.supportEmail,
        to: recipientEmailArray,
        subject: `${cycle === 0 ? 'Weekly' : 'Monthly'}_Report_For_Open_WOs`,
        text: ' ',
        html: ' ',
        attachments: [
          {
            content: attachment,
            filename: fileName,
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            disposition: 'attachment',
          },
        ],
      };

      this.emailService.sendEmail(mailOptions);
    } catch (e) {
      console.log(e);
    }
  }

  async sendCompletedWOReport(techIds, repicientIds, cycle, branch, company) {
    let allUsers = await this.userService.getAll(company);

    let technicians = allUsers.filter((user) =>
      techIds.includes(String(user.id)),
    );
    let recipients = allUsers.filter(
      (user) =>
        repicientIds.includes(String(user.id)) && user.isEnabled === true,
    );

    let completedWOArray = [];
    for (let tech of technicians) {
      let assignedWOs = await this.woService.findAssignedCompletedOrders(
        tech.id,
        branch.id,
      );
      completedWOArray.push(...assignedWOs);
    }

    let data = [];
    for (let order of completedWOArray) {
      const { primaryTech, secondaryTechs } = getPrimaryAndSecondaryTechs(
        order.assignedTechs,
      );

      const row = {
        number: order.number,
        type: order.type == 0 ? 'Service Call' : 'Quoted',
        customer: order.customer?.company,
        NTE: order.NTE,
        description: order.description,
        primaryTech: primaryTech,
        secondaryTechs: secondaryTechs,
        startDate: order.startDate
          ? moment(order.startDate).format('MM/DD/YYYY')
          : '',
        completedDate: order.completedDate
          ? moment(order.completedDate).format('MM/DD/YYYY')
          : '',
        status: getWorkOrderStatus(order.status),
      };
      data.push(row);
    }

    let recipientEmailArray = recipients.map((user) => user.email);

    const schema = [
      {
        column: 'WO#',
        type: String,
        width: 15,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.number,
      },
      {
        column: 'Type',
        type: String,
        width: 15,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.type,
      },
      {
        column: 'Customer',
        type: String,
        width: 20,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.customer,
      },
      {
        column: 'NTE',
        type: Number,
        width: 10,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.NTE,
      },
      {
        column: 'Description',
        type: String,
        width: 50,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.description,
      },
      {
        column: 'Primary Technician',
        type: String,
        width: 20,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.primaryTech,
      },
      {
        column: 'Secondary Technicians',
        type: String,
        width: 30,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.secondaryTechs,
      },
      {
        column: 'Date Started',
        type: String,
        width: 10,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.startDate,
      },
      {
        column: 'Date Completed',
        type: String,
        width: 15,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.completedDate,
      },
      {
        column: 'Status',
        type: String,
        width: 10,
        wrap: true,
        align: 'center',
        alignVertical: 'center',
        value: (order) => order.status,
      },
    ];

    const fileName = `${cycle === 0 ? 'Weekly' : 'Monthly'
      }_Report_For_Completed_WOs_${moment().format('YYYY_MM_DD')}.xlsx`;
    const filePath = `./public/${company}/reports/${fileName}`;
    if (!fs.existsSync(`./public/${company}/reports/`)) {
      fs.mkdirSync(`./public/${company}/reports/`, { recursive: true });
    }
    await writeXlsxFile(data, {
      schema,
      headerStyle: {
        backgroundColor: '#eeeeee',
        fontWeight: 'bold',
        align: 'center',
      },
      filePath: filePath,
    });

    let attachment = fs.readFileSync(filePath).toString('base64');

    try {
      const mailOptions = {
        from: config.mail.supportEmail,
        to: recipientEmailArray,
        subject: `${cycle === 0 ? 'Weekly' : 'Monthly'
          }_Report_For_Completed_WOs`,
        text: ' ',
        html: ' ',
        attachments: [
          {
            content: attachment,
            filename: fileName,
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            disposition: 'attachment',
          },
        ],
      };

      this.emailService.sendEmail(mailOptions);
    } catch (e) {
      console.log(e);
    }
  }

  async sendReviewedWOReport(techIds, repicientIds, cycle, branch, company) {
    let allUsers = await this.userService.getAll(company);

    let technicians = allUsers.filter((user) =>
      techIds.includes(String(user.id)),
    );
    let recipients = allUsers.filter(
      (user) =>
        repicientIds.includes(String(user.id)) && user.isEnabled === true,
    );

    let reviewedWOArray = [];
    for (let tech of technicians) {
      let assignedWOs = await this.woService.findAssignedReviewedOrders(
        tech.id,
        branch.id,
      );
      reviewedWOArray.push(...assignedWOs);
    }

    let data = [];
    for (let order of reviewedWOArray) {
      const row = {
        number: order.number,
        type: order.type == 0 ? 'Service Call' : 'Quoted',
        customer: order.customer?.company,
        NTE: order.NTE,
        description: order.description,
        technician: getAssignedTechsNameArray(order.assignedTechs),
        status: getWorkOrderStatus(order.status),
      };
      data.push(row);
    }

    let recipientEmailArray = recipients.map((user) => user.email);

    const fileName = `${cycle === 0 ? 'Weekly' : 'Monthly'
      }_Report_For_Reviewed_WOs_${moment().format('YYYY_MM_DD')}.xlsx`;
    const filePath = `./public/${company}/reports/${fileName}`;
    if (!fs.existsSync(`./public/${company}/reports/`)) {
      fs.mkdirSync(`./public/${company}/reports/`, { recursive: true });
    }
    await writeXlsxFile(data, {
      schema,
      headerStyle: {
        backgroundColor: '#eeeeee',
        fontWeight: 'bold',
        align: 'center',
      },
      filePath: filePath,
    });

    let attachment = fs.readFileSync(filePath).toString('base64');

    try {
      const mailOptions = {
        from: config.mail.supportEmail,
        to: recipientEmailArray,
        subject: `${cycle === 0 ? 'Weekly' : 'Monthly'
          }_Report_For_Reviewed_WOs`,
        text: ' ',
        html: ' ',
        attachments: [
          {
            content: attachment,
            filename: fileName,
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            disposition: 'attachment',
          },
        ],
      };

      this.emailService.sendEmail(mailOptions);
    } catch (e) {
      console.log(e);
    }
  }

  async sendBilledWOReport(techIds, repicientIds, cycle, branch, company) {
    let allUsers = await this.userService.getAll(company);

    let technicians = allUsers.filter((user) =>
      techIds.includes(String(user.id)),
    );
    let recipients = allUsers.filter(
      (user) =>
        repicientIds.includes(String(user.id)) && user.isEnabled === true,
    );

    let billedWOArray = [];
    for (let tech of technicians) {
      let assignedWOs = await this.woService.findAssignedBilledOrders(
        tech.id,
        branch.id,
      );
      billedWOArray.push(...assignedWOs);
    }

    let data = [];
    for (let order of billedWOArray) {
      const row = {
        number: order.number,
        type: order.type == 0 ? 'Service Call' : 'Quoted',
        customer: order.customer?.company,
        NTE: order.NTE,
        description: order.description,
        technician: getAssignedTechsNameArray(order.assignedTechs),
        status: getWorkOrderStatus(order.status),
      };
      data.push(row);
    }

    let recipientEmailArray = recipients.map((user) => user.email);

    const fileName = `${cycle === 0 ? 'Weekly' : 'Monthly'
      }_Report_For_Billed_WOs_${moment().format('YYYY_MM_DD')}.xlsx`;
    const filePath = `./public/${company}/reports/${fileName}`;
    if (!fs.existsSync(`./public/${company}/reports/`)) {
      fs.mkdirSync(`./public/${company}/reports/`, { recursive: true });
    }
    await writeXlsxFile(data, {
      schema,
      headerStyle: {
        backgroundColor: '#eeeeee',
        fontWeight: 'bold',
        align: 'center',
      },
      filePath: filePath,
    });

    let attachment = fs.readFileSync(filePath).toString('base64');

    try {
      const mailOptions = {
        from: config.mail.supportEmail,
        to: recipientEmailArray,
        subject: `${cycle === 0 ? 'Weekly' : 'Monthly'}_Report_For_Billed_WOs`,
        text: ' ',
        html: ' ',
        attachments: [
          {
            content: attachment,
            filename: fileName,
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            disposition: 'attachment',
          },
        ],
      };

      this.emailService.sendEmail(mailOptions);
    } catch (e) {
      console.log(e);
    }
  }

  //Send Time Card for every technician to Debbie's email address(debbie@refrigerationsystems.biz)

  // @Cron('0 19 * * 0', {
  //   timeZone: 'Pacific/Honolulu',
  // })
  // @Cron('0 3 * * *', {
  //   timeZone: 'Pacific/Honolulu',
  // })
  async sendTimeCardToOfficeManager() {
    let technicians = await this.userService.getUsersWithRole(
      'Technician',
      0,
      'rscs',
    );

    let startDate = moment().subtract(7, 'days').format('MM/DD/YYYY');
    let endDate = moment().subtract(1, 'days').format('MM/DD/YYYY');
    // let startDate = moment().subtract(8, 'days').format('MM/DD/YYYY');
    // let endDate = moment().subtract(2, 'days').format('MM/DD/YYYY');

    let attachments = [];
    for (let tech of technicians) {
      let timeArray = await this.technicianService.getWeeklyTimeCards(
        tech.id,
        startDate,
        endDate,
      );

      let timeCard = { name: tech.name, endingDate: endDate, timeArray };

      //calculate total regular time and over time for the week.

      let weekRegTime = 0;
      let weekOverTime = 0;

      for (let item of timeArray) {
        for (let time of item.timeArray) {
          if (time.regularTime) weekRegTime += time.regularTime;
          if (time.overTime) weekOverTime += time.overTime;
        }
      }

      timeCard['weekRegTime'] = weekRegTime;
      timeCard['weekOverTime'] = weekOverTime;

      //calculate the total regular time and over time for every day.
      let dayTotalHours = [];
      for (let i = 0; i < 7; i++) {
        let date = moment(startDate, 'MM/DD/YYYY').add(i, 'days');
        let regularTime = 0,
          overTime = 0;
        for (let time of timeArray) {
          for (let item of time.timeArray) {
            if (moment(item.date, 'MM/DD/YYYY').isSame(date, 'day')) {
              if (item.regularTime) regularTime += item.regularTime;
              if (item.overTime) overTime += item.overTime;
            }
          }
        }
        dayTotalHours.push({
          offset: i,
          date: date.format('YYYY-MM-DD'),
          regularTime: regularTime,
          overTime: overTime,
        });
      }

      timeCard['dayTotalHours'] = dayTotalHours;

      //creating PDF file

      let path =
        'src/core/templates/weeklytimecard/weekly_timecard_report_template.html';
      if (
        process.env.NODE_ENV === 'production' ||
        process.env.NODE_ENV === 'staging'
      ) {
        path =
          'core/templates/weeklytimecard/weekly_timecard_report_template.html';
      }

      const template = await fs.promises.readFile(path, 'utf-8');

      const renderedHtml = ejs.render(template, timeCard);

      let options = {
        format: 'A4',
        width: '8.5in',
        height: '11in',
        title: 'Service Ticket',
        margin: { top: 40, left: 20, right: 20, bottom: 20 },
      };
      let file = { content: renderedHtml };

      const pdfBuffer = await htmlPDF.generatePdf(file, options);

      const fileName = `Weekly_TimeCard_${tech.name}_${moment().format(
        'YYYY_MM_DD',
      )}.pdf`;
      const filePath = `./public/rscs/weeklytimecardreport/${fileName}`;

      await fs.promises.writeFile(filePath, pdfBuffer);

      const attachment = fs.readFileSync(filePath).toString('base64');
      attachments.push({
        content: attachment,
        filename: fileName,
        type: 'application/pdf',
        disposition: 'attachment',
      });
    }

    //send email
    const mailOptions = {
      from: config.mail.supportEmail,
      to: ['roland@makani.services', 'yigitmufata3@gmail.com'],
      // to: ['yigitmufata3@gmail.com'],
      subject: `Weekly Time Card Report`,
      text: `Weekly Time Card Report`,
      html: ' ',
      attachments: attachments,
    };
    this.emailService.sendEmail(mailOptions);
  }

  async sendDailyTimeLogReminder() {
    let company = 'rscs';
    let technicians = await this.userService.getUsersWithRole(
      'Technician',
      0,
      company,
    );
    let managers = await this.userService.getUsersWithRole(
      'Manager',
      0,
      company,
    );
    let userArray = [...technicians, ...managers];

    // Collect all eligible users who need to be notified
    const eligibleUsers: Array<{ user: any; email: string; id: number }> = [];

    for (let user of userArray) {
      // Check if user has branches
      if (!user.branches || user.branches.length === 0) {
        continue;
      }

      // Check each branch to see if it's 4:30 PM in that branch's timezone
      let branch = user.branches[0];
      if (!branch.timezone) {
        continue;
      }

      // Get the IANA timezone from the timezone map
      const ianaTimezone = timezoneMap[branch.timezone];

      if (!ianaTimezone) {
        continue;
      }

      // Get current time in the branch's timezone
      const currentHour = Number(momenttz().tz(ianaTimezone).format('HH'));
      const currentMinute = Number(momenttz().tz(ianaTimezone).format('mm'));
      // Check if it's 4:30 PM (16:30)
      if (currentHour === 16 && currentMinute === 30) {
        eligibleUsers.push({
          user,
          email: user.email,
          id: user.id,
        });
      }
    }
    // Send push notification to all eligible users at once
    if (eligibleUsers.length > 0) {
      try {
        const emails = eligibleUsers.map((u) => u.email);
        await this.pusherService.sendPushNotification(
          emails,
          'Daily Time Log Reminder',
          'Please remember to log your time for today.',
          { type: 'DAILY_TIME_LOG_REMINDER' },
        );

        // Update all user records in parallel
        await Promise.all(
          eligibleUsers.map((u) =>
            this.userRepo.update(u.id, {
              hasLoggedHoursToday: false,
            }),
          ),
        );
      } catch (error) {
        console.log('Error sending push notifications:', error);
      }
    }
  }

}
